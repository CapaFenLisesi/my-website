---
layout: default
feijoa: true
title: 7 Incremental construction | Thesis
file: thesis/incremental-construction.html
lang: en
mathjax: true
locale_es: /en/thesis/resumen.html
---

<div class="container">
	<nav aria-label="breadcrumb">
		<ol class="breadcrumb">
		  <li class="breadcrumb-item"><a href="index.html">Thesis</a></li>
		  <li class="breadcrumb-item active">7 Incremental construction</li>
		</ol>
	</nav>
	<h1>7 Incremental construction</h1>
	<div class="row">
		<div class="col col-12 col-md-9">
			<p class="text-justify">
				 One more method to the extrusion of <a href="extrusion.html">Chapter 6</a>, <em>incremental construction</em> exploits the property that an \(n\)-cell can be defined based on a set of \((n-1)\)-cells known to form its complete (closed) boundary. In practice, defining an \(n\)-cell in this manner is significantly more complex than doing so based on extrusion. However, unlike extrusion it permits the creation of cells of an <em>arbitrary shape</em>. It can also be applied cell by cell in increasing dimension, starting with the construction of isolated 0-cells (embedded in \(\mathbb{R}^n\)) first, and then constructing 2-cells, 3-cells and further based on their boundary, allowing for the <em>incremental construction</em> of objects of any dimension&mdash;hence the name given here. 
			</p>
			<p class="text-justify">
				 This chapter describes an operation that permits the aforementioned process to be easily applied in practice using a topological data structure. Based on combinatorial maps (<a href="nd-modelling.html#ss:ordered-topological-models">&sect;4.3.6</a>) and their fundamental operations (<a href="operations-background.html#ss:operations-maps">&sect;5.1.1</a>), it connects the separate boundary \((n-1)\)-cells together by computing the appropriate adjacency relationships between them, encapsulating low-level details such as the creation of new individual combinatorial elements and setting the correct orientation for the existing ones. 
			</p>
			<p class="text-justify">
				 The chapter begins with some background on the operations and a description of the overall approach in <a href="#se:incremental-approach">&sect;7.1</a>. It then explains the steps needed to create the cells of each dimension in <a href="#se:primitives">&sect;7.2</a>. <a href="#se:incremental-implementation">&sect;7.3</a> describes how the approach was implemented based on the Computational Geometry Algorithms Library (CGAL). <a href="#se:incremental-experiments">&sect;7.4</a> summarises some experiments based on this implementation, generating relatively large objects in up to 4D. Finally, <a href="#se:incremental-conclusions">&sect;7.5</a> concludes the chapter with the possibilities to use incremental construction to build higher-dimensional datasets. 
			</p>
			<p class="text-justify">
				 Most of this chapter is based on the paper:
			</p>
			{% imbiber pubs/phd.bib one:14icaa noimg %}
			<p class="text-justify">
				 <h2 id="se:incremental-approach">7.1 Background and overall approach</h2> 
			</p>
			<p class="text-justify">
				 Based on the Jordan-Brouwer separation theorem [<a href="bibliography.html#Lebesgue11">Lebesgue, 1911</a>; <a href="bibliography.html#Brouwer11">Brouwer, 1911</a>], it is known that a subset of space homeomorphic to an \((n-1)\)-dimensional sphere<a href="#fn109" id="fnref109"><sup>109</sup></a> \(S^{n-1}\) in the \(n\)-dimensional Euclidean space \(\mathbb{R}^n\) divides the space into two connected components: the <em>interior</em>, which is the region bounded by the sphere, and the <em>exterior</em>, which is the unbounded region in which the sphere is a hole. This means that the principles of boundary representation as described in <a href="modelling-background.html#ss:data-models">&sect;3.1.2</a> extend to higher dimensions, and so an \(n\)-cell in a cell complex can be described (and therefore constructed) based a set of \((n-1)\)-cells that are known to form its complete (closed) boundary<a href="#fn110" id="fnref110"><sup>110</sup></a>. 
			</p>
			<p class="text-justify">
				 The <em>incremental construction</em> method proposed in this chapter exploits this property by applying this process cell by cell in increasing dimension. Isolated vertices are first constructed, which are embedded in \(\mathbb{R}^n\) and are uniquely defined based on their coordinates. These vertices can then be connected to form individual edges, or instead to directly form cycles of implicit edges representing faces, as in most of the typical GIS approaches described in <a href="modelling-background.html#ss:formats">&sect;3.2.2</a>. Sets of faces can be connected to form volumes, sets of volumes to form 4-cells and so on. 
			</p>
			<p class="text-justify">
				 In a similar manner as extrusion, presented in <a href="extrusion.html">Chapter 6</a>, this <em>incremental construction</em> process significantly reduces the conceptual complexity of defining and creating higher-dimensional objects. The \((n-1)\)-dimensional boundary of an \(n\)-cell is much easier to conceive than the original \(n\)-cell because it can be subdivided into multiple simpler \((n-1)\)-cells, which can be individually described and constructed using the same method. 
			</p>
			<p class="text-justify">
				 However, applying this incremental construction process using a topological data structure is not that simple, as it involves many intricate small problems: finding the topological relationships between the cells, appropriately connecting them, keeping track of multiple connected components, avoiding the creation of duplicate cells (as part of the boundary of independently-described higher-dimensional cells), changing the orientation of cells on the fly (since those that have been created separately will often have incompatible orientations), and detecting non-manifold shapes (which would result in invalid structures), among others. 
			</p>
			<p class="text-justify">
				 The incremental construction operator presented in this chapter solves all of the aforementioned issues efficiently. It is based on \(n\)-dimensional combinatorial maps with linear geometries and it is fully dimension-independent. As it generates all the incidence and adjacency relationships between \((n-1)\)-cells in an \(n\)-dimensional cell complex, it can also be used to obtain these relationships when needed, such as when multiple datasets are combined into one or when a non-topological representation is instead used (e.g. the Simple Features-like approach shown in <a href="nd-modelling.html#ss:nd-topology">&sect;4.2.3</a>). 
			</p>
			<p class="text-justify">
				 In order to be efficient, the algorithm uses two basic techniques: (i) indexes on the lexicographically smallest vertex (<a href="operations-background.html#se:spatial-indexing">&sect;5.3</a>) of certain cells, which are used in order to keep track of individual cells (which might be disconnected) and to access cells efficiently; and (ii) signature-generating traversals for specific cells [<a href="bibliography.html#Gosselin11">Gosselin et al., 2011</a>], which are used to efficiently compare whether two cells are equivalent by checking if it is possible to find an isomorphism \(f\) that maps corresponding darts with equivalent (\(\beta\)) or reversed (\(\beta^{-1}\)) relations and which are embedded at the same location in \(\mathbb{R}^n\), as was shown in <a href="modelling-background.html#se:ndqueries">&sect;5.5</a>. 
			</p>
			<p class="text-justify">
				 The incremental construction operation as described in this chapter is applicable only to perfect data. The \((n-1)\)-cells bounding an \(n\)-dimensional cell should thus form a manifold and perfectly match each other at their common \((n-2)\)-dimensional boundaries. However, the method can be easily extended to handle some more complex configurations, such as by cleaning the input data using the methods described in <a href="cleaning.html">Chapter 10</a>. 
			</p>
			<p class="text-justify">
				 <h2 id="se:primitives">7.2 Incremental construction of primitives per dimension</h2> 
			</p>
			<p class="text-justify">
				 The idea of the incremental construction algorithm is to construct cells individually, using lower-dimensional cells that have already been constructed in order to describe part of the boundary of a higher-dimensional cell. In terms of the darts of a combinatorial map, this sometimes implies the reuse of existing darts, and sometimes the creation of new ones which are connected to the existing ones. There is however no strict requirement that the cells are created in strictly increasing dimension, and so new cells can be easily added to an existing cell complex. 
			</p>
			<p class="text-justify">
				 Due to the need to embed 0-cells into a point in space, as well as the oriented nature of a combinatorial map, the incremental construction method is different for 0-, 1- and 2-cells. 3-cells and those of higher dimensions follow a unified procedure. These cases are therefore described separately below, using as an example the creation of the pair of adjacent tetrahedra shown in <a href="#fig:2tetra" id="fig:2tetraref">Figure 7.1</a>.
			</p>
			<p class="text-justify">
				 <h3 id="ss:incremental-vertices">7.2.1 Vertices (0-cells)</h3>
			</p>
			<p class="text-justify">
				 The aim of the process of 0-cell construction is to create an isolated dart and an associated point embedding structure for every 0-cell, while avoiding having duplicate embedding structures having the same point coordinates. By making point embeddings unique&mdash;as defined by their coordinates&mdash;, they can be used to compare 0-cells without checking an entire tuple of coordinates. Moreover, by maintaining an index of all point embeddings and links from every point embedding to a dart there, it is possible to use this index to access the combinatorial structure at that point. In this manner, it is possible to find either an already free dart that can be reused, or a non-free dart that is part of a larger combinatorial structure, which can be then copied and its copy used instead. 
			</p>
			<p class="text-justify">
				 Thus, calling a function \(\texttt{make_0_cell(}x_0, \ldots, x_n\texttt{)}\) with the coordinates \(x_0, \ldots, x_n\) describing an \(n\)-dimensional point, should use the index of 0-cells to return an existing dart embedded at that location (using an existing point embedding) if one exists, or a new dart embedded at that location (using a new point embedding) otherwise. In the latter case, the new point embedding and its associated dart should be added to the index. The result of calling this function for all the point coordinates of the vertices in <a href="#fig:2tetra" id="fig:2tetraref">Figure 7.1</a> is shown in <a href="#fig:reconstruction-0" id="fig:reconstruction-0ref">Figure 7.2</a>. Note that the result is identical whether the function is called once for every unique vertex, or multiple times (e.g. once for every vertex in every face or volume).
			</p>
			<p class="text-justify">
				 <h3 id="ss:incremental-edges">7.2.2 Edges (1-cells)</h3>
			</p>
			<p class="text-justify">
				 Generally, it is best to skip the generation of 1-cells and proceed directly to the creation of 2-cells from sequences of points. In order to represent an isolated edge in a combinatorial map not one but <em>two</em> darts are required: one embedded at each of the two vertices bounding the edge. More precisely, taking into account the (arbitrary) orientation defined for the edge, the dart embedded at the <em>origin</em> of the edge is connected to the <em>destination</em> by \(\beta_1\), and the destination is connected to the origin by \(\beta_1^{-1}\). Having two darts per edge is not a major problem, but it is wasteful as it often creates unnecessary darts and unnecessary connections between them that would later be deleted. For instance, if a single face that uses all the edges is created from its bounding edges, half of the darts lose their original purpose (i.e.  to store a connection to their otherwise unlinked point embeddings) and will be eliminated<a href="#fn111" id="fnref111"><sup>111</sup></a>, which is accompanied with having to reset the \(\beta\) relationships pointing to them. 
			</p>
			<p class="text-justify">
				 In addition, as shown in <a href="modelling-background.html#ss:formats">&sect;3.2.2</a>, polygons can be easily described as an ordered sequence of vertices connected by implicit line segments between each consecutive pair. Therefore, incrementally constructing \(1\)-cells often brings no efficiency gains or practical benefits, and so it is normally best to skip dimension one, constructing 2D facets from a sequence of 0D points, 3D volumes from their 2D faces, 4-cells from their 3-cell faces, and so on. 
			</p>
			<p class="text-justify">
				 However, there is an exception to this rule, as isolated edges and polygonal lines sometimes do need to be explicitly represented. In these cases, it is possible to simply follow the process described for 2-cells below, omitting sewing the last dart of the line segment or polygonal line to the first dart (and vice versa), and appropriately using the 1-cells index to find if a given 1-cell already exists, or otherwise to index the newly created 1-cell or 1-cells (in the case of a polygonal line). 
			</p>
			<p class="text-justify">
				 <h3 id="ss:incremental-faces">7.2.3 Faces (2-cells)</h3>
			</p>
			<p class="text-justify">
				 Starting from the unique 0-cells obtained from the procedure presented in <a href="#ss:incremental-vertices">&sect;7.2.1</a>, in order to create a 2-cell from a sequence of 0-cells, three general steps are needed:
			</p>
			<ol>
				<li>
					<p class="text-justify">The procedure first checks if the 2-cell that is being requested already exists<a href="#fn112" id="fnref112"><sup>112</sup></a>. Just as in the creation of 0-cells, a 2-cell being requested might have already been created, either independently or as part of a 3-cell. This can be easily checked using the index of 2-cells with the lexicographically smallest vertex of the 0-cells being passed, and finding if from a dart starting at the lexicographically smallest vertex and following the \(\beta_1\) or \(\beta_1^{-1}\) relations, one passes through the same point embeddings as those passed to this construction method.
					</p>
				</li>
				<li>
					<p class="text-justify">Each of these 0-cells might be a \(1\)-free dart \(d\) (i.e.  \(\beta_1(d) = \emptyset\)) and thus have no dart linked to it by \(\beta_1\), i.e.  \(\beta_1^{-1}(d) = \emptyset\) or \(\forall d^\prime \nexists \beta_1(d^\prime) = d\), or if \(\beta_1^{-1}\) is not stored, \(\nexists d^\prime \mid \beta_1(d^\prime) = d\), <em>in which case it can be used directly</em>, such as in <a href="#subfig:reconstruction-2-a" id="subfig:reconstruction-2-aref">Figure 7.3</a>. It can also be a non \(1\)-free dart or one that has a dart linked by \(\beta_1\) to it, which means that it is used as part of a \(1\)-cell (and possibly other higher dimensional cells).</p>

					<p class="text-justify">The darts that are already used as part of \(1\)-cells are more difficult to handle, as they <em>can be reused only when the 1-cell they are part of is also part of the boundary of a geometrically identical \(2\)-cell as the one that will be constructed using this method</em>. This needs to be tested in both possible orientations for the sequence of 0-cells, possibly resulting in the reversal of the orientation of some 1-cells. If a given dart <em>cannot be reused</em> (because it is part of a 1-cell that is not part of the 2-cell to be created), a copy of it has to be created. The result of this step is thus a list that contains for every 0-cell a reusable existing dart or a newly created dart.</p>
				</li>
				<li>
					<p class="text-justify">The darts obtained in the previous step are 1-sewn sequentially (using \(\beta_1\) and \(\beta_1^{-1}\)), and the last is 1-sewn to the first, forming a closed cycle. During these sewing operations, the function checks whether every newly created edge (consisting of a pair of linked darts) is present in the index of 1-cells. If a given 1-cell is already there, the new edge&rsquo;s dart is linked to its edge embedding structure. If a 1-cell is not there, the edge is added to the index<a href="#fn113" id="fnref113"><sup>113</sup></a>, a new edge embedding is created, and the edge&rsquo;s dart is linked to it. Finally, the newly created 2-cell is then added to the index of 2-cells. </p>
					<p class="text-justify">In order to verify that the 2-cell being generated is a quasi-manifold, it is useful to assert that all darts that are \(1\)-free and have their \(\beta_1^{-1}\) relation set to \(\emptyset\) at the beginning of this third step, i.e. those that were not copied, should continue to be \(1\)-free and have a \(\beta_1^{-1}\) set to \(\emptyset\) until they are sewn. This condition, which is applied differently to the 1-cell, ensures that a vertex is not used twice within the same face, and as such, that the 2-cell is a quasi-manifold. </p>
				</li>
			</ol>
			<p class="text-justify">
				 <a href="#fig:reconstruction-2" id="fig:reconstruction-2ref">Figure 7.3</a> shows the incremental construction procedure for all the 2-cells of <a href="#fig:2tetra" id="fig:2tetraref">Figure 7.1</a>, which consists of 7 2-cells and is thus obtained by 7 calls to the \(\texttt{make_2_cell}\) method. 
			</p>
			<div class="row" id="fig:reconstruction-2">
				<div class="col col-3"><img src="figs/reconstruction-2.svg" class="img-fluid" /><p class="small text-center">(a)</p></div>
				<div class="col col-3"><img src="figs/reconstruction-2-a.svg" class="img-fluid" /><p class="small text-center">(b)</p></div>
				<div class="col col-3"><img src="figs/reconstruction-2-b.svg" class="img-fluid" /><p class="small text-center">(c)</p></div>
				<div class="col col-3"><img src="figs/reconstruction-2-c.svg" class="img-fluid" /><p class="small text-center">(d)</p></div>
			</div>
			<div class="row">
				<div class="col col-3"><img src="figs/reconstruction-2-d.svg" class="img-fluid" /><p class="small text-center">(e)</p></div>
				<div class="col col-3"><img src="figs/reconstruction-2-e.svg" class="img-fluid" /><p class="small text-center">(f)</p></div>
				<div class="col col-3"><img src="figs/reconstruction-2-f.svg" class="img-fluid" /><p class="small text-center">(g)</p></div>
				<div class="col col-3"><img src="figs/reconstruction-2-g.svg" class="img-fluid" /><p class="small text-center">(h)</p></div>
			</div>
			<div class="row">
				<div class="col col-12"><p class="small text-justify">Figure 7.3: The construction of the 2-cells of <a href="#fig:2tetra" id="fig:2tetraref">Figure 7.1</a>. (a) Initial configuration: one dart per vertex. (b) After \(b=\texttt{make_2_cell(}1,2,3\texttt{)}\). (c) After \(c=\texttt{make_2_cell(}2,4,3\texttt{)}\). (d) After \(d=\texttt{make_2_cell(}1,4,3\texttt{)}\). (e) After \(e=\texttt{make_2_cell(}1,4,2\texttt{)}\). (f) After \(f=\texttt{make_2_cell(}1,3,5\texttt{)}\). (g) After \(g=\texttt{make_2_cell(}5,3,4\texttt{)}\). (h) Final result, after \(h=\texttt{make_2_cell(}4,5,1\texttt{)}\).<a href="#fig:reconstruction-2ref">&#8617;</a></p></div>
			</div>
			<p class="text-justify">
				 <h3 id="ss:incremental-volumes">7.2.4 Volumes (3-cells) and higher</h3> 
			</p>
			<p class="text-justify">
				 The method to create \(i\)-cells from their \((i-1)\)-cell boundaries is identical for all \(i \geq 3\), allowing for a fully dimension-independent function to be created. This function consists of four general steps: 
			</p>
			<ol>
				<li>
					<p class="text-justify">
				 		First of all, the procedure checks whether each \((i-1)\)-cell that is passed is \((i-1)\)-free or not. If it is \((i-1)\)-free, it is reused as part of the \(i\)-cell, such as in <a href="#subfig:reconstruction-3-a" id="subfig:reconstruction-3-aref">Figure 7.5</a>. If it is not \((i-1)\)-free, then it is already part of a different \(i\)-cell, so a copy of it is made <em>with a reversed orientation</em>, as shown in <a href="#subfig:reconstruction-3-b" id="subfig:reconstruction-3-bref">Figure 7.6</a>. This copy can then be used for the construction of the \(i\)-cell. 
					</p>
					<p class="text-justify">
						 For a given dart \(d\) that is known to be part of the \((i-1)\)-cell, this copy can be made by taking all the darts in the orbit \(C = \langle \beta_1, \ldots, \beta_{i-2} \rangle (d)\), creating a new set of darts \(C^\prime\), and inserting a new corresponding dart in \(C^\prime\) for every dart in \(C\). Using a function \(f : C \rightarrow C^\prime\) that maps a dart in \(C\) to its corresponding dart in \(C^\prime\), for every dart \(c \in C\) the \(\beta_1\) relations are set as \(\beta_1^{-1}\left(f\left(c\right)\right) = f\left(\beta_1\left(c\right)\right)\) and \(\beta_1\left(f\left(c\right)\right) = f\left(\beta_1^{-1}\left(c\right)\right)\). For the ones of higher dimensions, they are set such that \(\forall 2 \leq j \leq i-2\), \(\beta_j\left(f\left(c\right)\right) = f\left(\beta_j\left(c\right)\right)\). 
					</p>
					<p class="text-justify">
						 Note that the combinatorial structures are copied with reversed orientation, as this ensures that the two (old and new) can be directly \(i\)-sewn together, if necessary. 
					</p>
				</li>
				<li>
					<p class="text-justify">
						 A temporary <em>ridge index</em> of the \(i\)-cell is built, containing all the \((i-2)\)-cells on the boundary of all \((i-1)\)-cells that have been passed to the construction method&mdash;not all the \((i-1)\)-cells in the cell complex&mdash;using their lexicographically smallest vertices, such that their index entries link to a usable dart in the \((i-2)\)-cell with a point embedding at the lexicographically smallest vertex. This dart should be one that is \((i-1)\)-free, either because it was already free as part of the combinatorial structure of the passed \((i-1)\)-cells, or because it is a copy (with reversed orientation) of one that was not \((i-1)\)-free. 
					</p>
				</li>
				<li>
					<p class="text-justify">
						 Using the ridge index, \((i-1)\)-cells (i.e.  facets) are \((i-1)\)-sewn along their common \((i-2)\)-cell boundaries (i.e.  ridges). For this, for every \((i-2)\)-cell on the boundary of an \((i-1)\)-cell passed to the function, exactly one matching \((i-2)\)-cell should be found in the index, which should be equivalent as compared using the method described in <a href="operations-background.html#se:ndqueries">&sect;5.5</a> and might be of the same or opposite orientation (but should not be part of the same \((i-1)\)-cell or matched to itself). This criterion ensures that a quasi-\((i-1)\)-manifold will be constructed. 
					</p>
					<p class="text-justify">
						 If the two \((i-1)\)-cells are sewable along their common \((i-2)\)-cell boundaries, i.e.  they have compatible orientations, they are directly sewn together. Otherwise, the orientation of the entire connected component of either of the two \((i-1)\)-cells should be reversed. If the two \((i-1)\)-cells have incompatible orientations but are part of the same connected component, the cell that is being requested is unorientable, and thus cannot be represented using combinatorial maps. Although not discussed further here, note that as long as it does forms a quasi-manifold it can however be represented using <em>generalised maps</em>. 
					</p>
				</li>
				<li>
					<p class="text-justify">
						 Using the index of \(i\)-cells, the newly constructed \(i\)-cell is compared to others to check if it had already been created, which is also done using the lexicographically smallest vertex of the cell. If an equivalent \(i\)-cell (with the same or opposite orientation) is found, the function deletes the newly created darts of the cell and their corresponding index entries, and instead finally returns the existing \(i\)-cell. If an equivalent \(i\)-cell is not found, the newly created cell is added to the index and returned. 
					</p>
				</li>
			</ol>
			<p class="text-justify">
				 <a href="#fig:reconstruction-3" id="fig:reconstruction-3ref">Figure 7.4</a> shows the incremental construction procedure for the two 3-cells of <a href="#fig:2tetra" id="fig:2tetraref">Figure 7.1</a>.
			</p>
			<p class="text-justify">
				 <h2 id="se:incremental-implementation">7.3 Implementation and complexity analysis</h2> 
			</p>
			<p class="text-justify">
				 The incremental construction algorithm has been implemented in C++11 and made available under the open source MIT licence at <a href="https://github.com/kenohori/lcc-tools">https://github.com/kenohori/lcc-tools</a>. As the extrusion related code (<a href="extrusion.html#se:extrusion-implementation">&sect;6.3</a>), it requires and builds upon the CGAL packages Combinatorial Maps and Linear Cell Complex, among others. 
			</p>
			<p class="text-justify">
				 For this prototype implementation, the lexicographically smallest vertex indices were implemented as C++ Standard Library <code>maps</code><a href="#fn114" id="fnref114"><sup>114</sup></a> for every dimension, using point embeddings as keys and <code>lists</code> of darts as values. Each dart in a <code>list</code> represents a separate cell (of the dimension of the index) that has that point as its lexicographically smallest. A custom comparison function is passed as a template so that the points are internally sorted in lexicographical order. As a <code>map</code> has \(O(\log n)\) search, insertion and deletion times and \(O(n)\) space [<a href="bibliography.html#ISO14882:2015">ISO, 2015, &sect;23.4</a>], all of these operations can be performed efficiently. 
			</p>
			<p class="text-justify">
				 If a strictly incremental approach is followed, creating all \(i\)-cells before proceeding to the \((i+1)\)-cells, it is not necessary to maintain indices for all the cells of all dimensions at the same time. The only ones that are needed are those for: all \(i\)- and \((i-1)\)-cells, as well as a temporary index for the \((i-2)\)-cells on the boundary of the \((i-1)\)-cells for the \(i\)-cell that is currently being constructed. This means that only three indexes&mdash;one of which likely covers only a small part of the dataset&mdash;need to be kept at a given time. 
			</p>
			<p class="text-justify">
				 Most of these indices can be easily built incrementally, adding new cells as they are created in \(O(\log c)\), with \(c\) the number of cells of that dimension, assuming that the smallest vertex and a dart embedded there are kept during its construction. The complexity of building any index of cells of any dimension is thus \(O(c \log c)\) and it uses \(O(c)\) space. 
			</p>
			<p class="text-justify">
				 Checking whether a given cell already exists in the cell complex is more complex. Finding a list of cells that have a certain smallest vertex is done in \(O(\log c)\). In an unrealistically pathological case, all existing cells in the complex could have the same smallest vertex, leading to up to \(c\) quadratic time cell-to-cell comparisons just to find whether one cell exists. However, every dart is only part of <em>a single</em> cell of any given dimension<a href="#fn115" id="fnref115"><sup>115</sup></a>, so while every dart could conceivably be a starting point for the comparison, a single dart cannot be used as a starting point in more than one comparison, and thus a maximum of \(d_{\mathrm{complex}}\) identity comparisons will be made for <em>all</em> cells, with \(d_{\mathrm{complex}}\) being the total number of darts in the cell complex. From these \(d_{\mathrm{complex}}\) darts, two identity comparisons are started, one assuming that the two cells (new and existing) have the same orientation, and one assuming opposite orientations. Each of these involves a number of dart-to-dart comparisons in the canonical representations that <em>cannot</em> be higher than the number of darts in the smallest of the two cells. The number of darts in the existing cell is unknown, but starting from the number of darts in the newly created cell (\(d_{\mathrm{cell}}\)), it is safe to say that no more than \(d_{\mathrm{cell}}\) dart-to-dart comparisons will be made in each identity test, leading to a worst-case time complexity of \(O(d_{\mathrm{complex}} d_{\mathrm{cell}})\). Note that this is similar to an isomorphism test starting at every dart of the complex. 
			</p>
			<p class="text-justify">
				 Finally, creating an \(i\)-cell from a set of \((i-1)\)-cells on its boundary is more expensive, since the \((i-2)\)-cell (ridge) index needs to be computed for every \((i-1)\)-cell. Following the same reasoning as above, it can be created in \(O(r \log r)\) with \(r\) the number of ridges in the \(i\)-cell, and uses \(O(r)\) space. Checking whether a single ridge has a corresponding match in the index is done in \(O(d_{\mathrm{cell}} d_{\mathrm{ridge}})\), with \(d_{\mathrm{cell}}\) the number of darts in the \(i\)-cell and \(d_{\mathrm{ridge}}\) the number of darts in the ridge to be tested. Since this is done for all the ridges in an \(n\)-cell, the total complexity of this step, which dominates the running time of the algorithm, is 
			</p>
			<p class="text-justify">
				 \begin{equation*} \displaystyle\sum_{\mathrm{ridges}} O(d_{\mathrm{cell}} d_{\mathrm{ridge}}) = O(d_{\mathrm{cell}}^{2}). \end{equation*} 
			</p>
			<p class="text-justify">
				 The analyses given above give an indication of the computational and space complexity of the incremental algorithm as a whole. However, it is worth noting that in realistic cases the algorithm fares far better than in these worst-case scenarios: the number of cells that have a certain smallest vertex is normally far lower than the total number of cells in the complex, most of their darts are not embedded at the smallest vertex, and from these darts most identity comparisons will fail long before reaching the end of their canonical representations. 
			</p>
			<p class="text-justify">
				 Finally, one more nuance can affect the performance of this approach. When two connected components of darts with incompatible orientations have to be joined, the orientation of one of these has to be reversed. This is easily done by obtaining all the connected darts of one of the connected components, preferably the one that is expected to be smaller, and reversing their orientation 2-cell by 2-cell. Every dart \(d\) in a 2-cell is then \(1\)-sewn to the previous dart in the polygonal curve of the 2-cell (i.e.  \(\beta_{1}^{-1}(d)\)). A group of \(n\) darts can thus have its orientation reversed in \(O(n)\) time. This is not a problem in practice since GIS datasets generally store nearby objects close together, but if a cell complex is incrementally constructed in the worst possible way, i.e.  creating as many disconnected groups as possible, this could have to be repeated for <em>every</em> cell of every dimension, creating a very inefficient process. 
			</p>
			<p class="text-justify">
				 <h2 id="se:incremental-experiments">7.4 Experiments</h2> 
			</p>
			<p class="text-justify">
				 <h3>Simple comparisons with valid primitives</h3>
			</p>
			<p class="text-justify">
				 The CGAL Linear Cell Complex package provides functions to generate a series of primitives (line segments, triangles, quadrangles, tetrahedra and hexahedra) which are known to be created with correct geometry and topology, and can then be sewn together to generate more complex models. Models constructed in this manner were thus created independently and compared to those incrementally constructed using the method presented in this chapter. By using the approach shown in <a href="operations-background.html#se:ndqueries">&sect;5.5</a>, it was possible to validate that they were equivalent. 
			</p>
			<p class="text-justify">
				 <h3>A tesseract</h3>
			</p>
			<p class="text-justify">
				 In order to present an example in more than three dimensions, a tesseract was also incrementally constructed using the approach presented in this chapter, which is shown in <a href="#fig:tesseract-darts" id="fig:tesseract-dartsref">Figure 7.5</a>. A tesseract is a 4-cell bounded by 8 cubical 3-cells, each of which is bounded by 6 square 2-cells. It thus consists of one 4-cell, 8 3-cells, 24 2-cells, 32 1-cells and 16 0-cells.
			</p>
			<p class="text-justify">
				 Using the approach presented here, an empty 0-cell index is first created. Then, the 16 vertices of the tesseract, each vertex \(p_{i}\) being described by a tuple of coordinates \((x_{i},y_{i},z_{i},w_{i})\), were created as \(p_{i}=\texttt{make_0_cell(}x_{i},y_{i},z_{i},w_{i}\texttt{)}\), which returns a unique dart embedded at each location that is also added to the 0-cell index. At this point, the algorithm has built an unconnected cell complex consisting solely of 16 completely free darts. 
			</p>
			<p class="text-justify">
				 An empty index of 2-cells is then created. Each of the tesseract&rsquo;s 24 square facets are then built based on their vertices as \(f_{i}=\texttt{make_2_cell(}p_{j},p_{k},p_{l},p_{m}\texttt{)}\), which 1-sews (copies of) these darts in a loop and returns the dart embedded at the smallest vertex of the facet. These are added to the index of 2-cells. Since every vertex is used in 6 different 2-cells, each dart would be copied 5 times. The cell complex at this point thus consists of 24 disconnected groups of 4 darts each. 
			</p>
			<p class="text-justify">
				 Next, an empty index of 3-cells is created and the index of 0-cells can be deleted. For each of the 8 cubical 3-cells, a function call of the form \(v_{i}=\texttt{make_3_cell(}f_{j},f_{k},f_{l},f_{m},f_{n},f_{o}\texttt{)}\) is made. At this point, an index of the 1D ridges of each face is built, which is used to find the 12 pairs of corresponding ridges that are then be 2-sewn together. When a 3-cell is created, it is added to the index. Since every face bounds two 3-cells, each dart is duplicated once again, resulting in a cell complex of 8 disconnected groups of 24 darts each. 
			</p>
			<p class="text-justify">
				 Finally, the tesseract is created with the function \(t=\texttt{make_4_cell(}v_{1},v_{2},\dots,v_{8}\texttt{)}\). This can use the index of 2-cells to find the 24 corresponding pairs of facets that are then 3-sewn to generate the final cell complex. 
			</p>
			<p class="text-justify">
				 The validity of this object was tested by checking whether it formed a valid combinatorial map, testing whether each cube was identical to a cube created with the Linear Cell Complex package, and manually verified the \(\beta\) links of its 192 darts. 
			</p>
			<p class="text-justify">
				 <h3>2D+scale data</h3>
			</p>
			<p class="text-justify">
				 In order to test the incremental construction algorithm and its applicability to data incorporating non-spatial characteristics, a few 2D+scale datasets from <a href="bibliography.html#Meijers11">Meijers [2011]</a> using ATKIS data<a href="#fn116" id="fnref116"><sup>116</sup></a>, were also incrementally constructed. As shown in <a href="#fig:utm" id="fig:utmref">Figure 7.6</a>, these datasets model the generalisation of a planar partition as a set of stacked prisms. Both of the simple datasets of this figure were created successfully in under a second.
			</p>
			<p class="text-justify">
				 A larger dataset, shown in <a href="#fig:atkis" id="fig:atkisref">Figure 7.7</a> and consisting of 698 polyhedra with a total of 457 185 faces, was used as a benchmark to test the performance of the algorithm. This dataset was processed without errors in roughly 30 minutes, including validation tests to ensure that every face created was a valid combinatorial map and that the faces of a volume formed a closed quasi-manifold.
			</p>
			<div class="row" id="fig:atkis">
				<div class="col col-12"><img src="figs/atkis.jpg" class="img-fluid" /></div>
				<div class="col col-12"><p class="small text-justify">Figure 7.7: A large 2D+scale dataset from <a href="bibliography.html#Meijers11">Meijers [2011]</a>, which uses equally spaced generalisation operations that merge two adjacent polygons.<a href="#fig:atkisref">&#8617;</a></p></div>
			</div>
			<p class="text-justify">
				 In this latter dataset, an additional test was made using its first 250 polyhedra, which lie on the top of <a href="#fig:atkis" id="fig:atkisref">Figure 7.7</a>, comparing the time used for the construction of vertices, faces and volumes with and without the use of indices. The results of both methods were equivalent using the approach shown in <a href="operations-background.html#se:ndqueries">&sect;5.5</a>. On average, using indices resulted in a faster vertex construction time by a factor of 2 200, faster face construction by a factor of 56 and faster volume construction by a factor of 38. However, as <a href="#fig:construction-times" id="fig:construction-timesref">Figure 7.8</a> shows, these speed gains are not uniform throughout the 250 polyhedra. The speed gained from using an index on the vertices increases roughly linearly on the number of constructed vertices, while that gained on from the faces index remains roughly constant between a factor of 50 and 60, and that gained from the volumes index tends to slowly increase as well. 
			</p>
			<div class="row" id="fig:construction-times">
				<div class="col col-4"><img src="figs/construction-vertices.svg" class="img-fluid" /><p class="small text-center">(a)</p></div>
				<div class="col col-4"><img src="figs/construction-faces.svg" class="img-fluid" /><p class="small text-center">(b)</p></div>
				<div class="col col-4"><img src="figs/construction-volumes.svg" class="img-fluid" /><p class="small text-center">(c)</p></div>
				<div class="col col-12"><p class="small text-justify">Figure 7.8: Construction time speed-up from the use of indices on the (a) vertices, (b) faces and (c) volumes.<a href="#fig:construction-timesref">&#8617;</a></p></div>
			</div>
			<p class="text-justify">
				 <h2 id="se:incremental-conclusions">7.5 Conclusions</h2> 
			</p>
			<p class="text-justify">
				 Creating computer representations of higher-dimensional objects can be complex. Common construction methods used in 3D, such as directly manipulating combinatorial primitives, or using primitive-level construction operations (e.g.  Euler operators [<a href="bibliography.html#Mantyla88">M&auml;ntyl&auml;, 1988</a>]), rely on our intuition of 3D geometry, and thus do not work well in higher dimensions. It is therefore all too easy to create invalid objects, which then cannot be easily interpreted or fixed. 
			</p>
			<p class="text-justify">
				 The incremental construction method proposed in this section follows a completely different approach, which has a solid underpinning in the Jordan-Brouwer separation theorem [<a href="bibliography.html#Lebesgue11">Lebesgue, 1911</a>; <a href="bibliography.html#Brouwer11">Brouwer, 1911</a>]. By exploiting the principles of boundary representation, it constructs an \(i\)-cell based on a set of its bounding \((i-1)\)-cells. Since individual \((i-1)\)-cells are easier to describe than the \(i\)-cell, it thus subdivides a complex representation problem into a set of simpler, more intuitive ones. The method can moreover be incrementally applied to construct cell complexes of any dimension, starting from a set of vertices in \(\mathbb{R}^n\) as defined by a \(n\)-tuple of their coordinates, and continuing with cells of increasing dimension&mdash;optionally creating edges from vertices, then faces from vertices or edges, volumes from faces and so on. 
			</p>
			<p class="text-justify">
				 While a set of \((i-1)\)-cells bounding an \(i\)-cell can be said to already form a complete representation of an \(i\)-cell, this is not sufficient for its representation in a topological data structure, which requires the topological relationships between the \((i-1)\)-cells to be computed. The incremental construction algorithm proposed in this section thus computes the relationships that are required for two data structures: generalised or combinatorial maps. However, these relationships are also applicable to most other data structures. 
			</p>
			<p class="text-justify">
				 The algorithm is efficient due to its use of indices using the lexicographically smallest vertex of every cell per dimension, as well as an added index using the lexicographically smallest vertex of the bounding ridges of the cell that is being built. It generates an \(i\)-cell in \(O(d^{2})\) in the worst case, with \(d\) the total number of darts in the cell. However, it fares markedly better in real-world datasets, as cells do not generally share the same lexicographically smallest vertex. By checking all matching ridges within a cell&rsquo;s facets, the algorithm can optionally verify that the cell being constructed forms a combinatorially valid quasi-manifold, avoiding the construction of invalid configurations. 
			</p>
			<p class="text-justify">
				 A publicly available implementation of the algorithm has been made based on CGAL Combinatorial Maps, and its source code has been released under a permissive licence. It is worth noting that it is one of very few general-purpose object construction methods that has been described and implemented for four- or higher-dimensional cell complexes. 
			</p>
			<p class="text-justify">
				 The implementation has been tested with simple 2D&ndash;4D objects, as well as with large 2D+scale datasets from <a href="bibliography.html#Meijers11">Meijers [2011]</a>. The constructed objects were tested to verify that they form valid combinatorial maps. The small objects were also manually inspected, visualised, and where possible, they were compared with equivalent objects known to be valid using the method discussed in <a href="operations-background.html#se:ndqueries">&sect;5.5</a>. 
			</p>
			<p class="text-justify">
				 While the incremental construction operation as described in this chapter works only with perfect data, small modifications could make it applicable to additional configurations. For instance, merging adjacent cells that can be perfectly described by a single cell with linear geometry (e.g.  collinear edges and coplanar faces) as a preprocessing step can be used to handle cases where cells are subdivided only on one side of a boundary. Snapping points together can solve several common invalid configurations, such as those described in <a href="cleaning.html">Chapter 10</a> and in <a href="bibliography.html#Diakite14">Diakit&eacute; et al. [2014]</a>. 
			</p>
			<p class="text-justify">
				 Finally, the logical step forward at this point would be the use of the incremental construction algorithm for the creation of large higher-dimensional datasets. However, since to the best of my knowledge there are no large space-filling higher-dimensional datasets currently available&mdash;without even considering any validity criteria&mdash;, such tests could not be conducted within this thesis. The generation of such a higher-dimensional dataset is thus a necessary first step in this direction and is considered as a related piece of future work. 
			</p>
		</div>
		<div class="col col-12 col-md-3">
			<p id="fn109" class="small text-justify">
				109. A generalisation of the concept of a sphere in arbitrary dimensions. A 0-sphere is the pair of points, a 1-sphere is a circle, and a 2-sphere a sphere. As opposed to disks and balls, circles and spheres are hollow.<a href="#fnref109">&#8617;</a>
			</p>
			<p id="fn110" class="small text-justify">
				110. This is true in practice. However, there are fractal-like pathological objects where this is not the case because their interior or exterior components are not homeomorphic to disks [<a href="bibliography.html#Alexander24">Alexander, 1924</a>]. While they do exist, this type of objects are certainly out of scope here.<a href="#fnref110">&#8617;</a>
			</p>
			<div class="row" id="fig:2tetra">
				<div class="col col-12 col-sm-6 col-md-12"><img src="figs/2tetra.svg" class="img-fluid" /><p class="small text-center">(a)</p></div>
				<div class="col col-12 col-sm-6 col-md-12"><img src="figs/2tetra-map.svg" class="img-fluid" /><p class="small text-center">(b)</p></div>
				<div class="col col-12"><p class="small text-justify">Figure 7.1: (a) Two adjacent tetrahedra and (b) their representation as a combinatorial map.<a href="#fig:2tetraref">&#8617;</a></p></div>
			</div>
			<p id="fig:reconstruction-0"><img src="figs/reconstruction-0.svg" class="img-fluid" /></p>
			<p class="small">
				Figure 7.2: Constructing the 0-cells of <a href="#fig:2tetra" id="fig:2tetraref">Figure 7.1</a> consists of creating exactly one dart embedded at each point. These darts are isolated (i.e.  not linked by any \(\beta\) relations to the other darts). The direction of the arrows shown here is arbitrary.<a href="#reconstruction-0ref">&#8617;</a>
			</p>
			<p id="fn111" class="small text-justify">
				111. These could be those embedded at the edges&rsquo; origin, destination or a mixture of the two.<a href="#fnref111">&#8617;</a>
			</p>
			<p id="fn112" class="small text-justify">
				112. This test can also be done at the end of the process, which makes it possible to use the easy cell comparison method described in <a href="operations-background.html#se:ndqueries">&sect;5.5</a>. In that case, the newly created cells (in the form of darts) that are found to be redundant should be deleted and removed from (or not added to) the indices.<a href="#fnref112">&#8617;</a>
			</p>
			<p id="fn113" class="small text-justify">
				113. Here, depending on the kind of expected input data, it might be more convenient to index edges at their origin vertex rather than at their lexicographically smallest.<a href="#fnref113">&#8617;</a>
			</p>
			<div class="row" id="fig:reconstruction-3">
				<div class="col col-12 col-sm-6 col-md-12"><img src="figs/reconstruction-3-a.svg" class="img-fluid" /><p class="small text-center">(a)</p></div>
				<div class="col col-12 col-sm-6 col-md-12"><img src="figs/reconstruction-3-b.svg" class="img-fluid" /><p class="small text-center">(b)</p></div>
				<div class="col col-12"><p class="small text-justify">Figure 7.4: The construction of the 3-cells of <a href="#fig:2tetra" id="fig:2tetraref">Figure 7.1</a>. (a) After \(\texttt{make_3_cell(}b,c,d,e\texttt{)}\). (b) Final result, after \(\texttt{make_3_cell(}e,f,g,h\texttt{)}\).<a href="#fig:reconstruction-3ref">&#8617;</a></p></div>
			</div>
			<p id="fn114" class="small text-justify">
				114. The exact implementation depends on the library that is used, but normally they are red-black trees.<a href="#fnref114">&#8617;</a>
			</p>
			<p id="fn115" class="small text-justify">
				115. This is true for the type of combinatorial maps with linear geometries that are handled here, but not necessarily so in the general case.<a href="#fnref115">&#8617;</a>
			</p>
			<div class="row" id="fig:tesseract-darts">
				<div class="col col-12 col-sm-4 col-md-12"><img src="figs/tesseract2.svg" class="img-fluid" /><p class="small text-center">(a)</p></div>
				<div class="col col-12 col-sm-4 col-md-12"><img src="figs/tesseract3.svg" class="img-fluid" /><p class="small text-center">(b)</p></div>
				<div class="col col-12 col-sm-4 col-md-12"><img src="figs/tesseract.svg" class="img-fluid" /><p class="small text-center">(c)</p></div>
				<div class="col col-12"><p class="small text-justify">Figure 7.5: A tesseract as a combinatorial map: (a) the darts of its 7 inner cubes, (b) the darts of its 8 cubes, and (c) all of its darts shown together.<a href="#fig:tesseract-dartsref">&#8617;</a></p></div>
			</div>
			<p id="fn116" class="small text-justify" style="word-break: break-word;">
				116. <a href="http://www.bkg.bund.de/nn_147094/SharedDocs/Download/Barrierefreie-Textversionen/EN-InfoMaterial/EN-Text-Vector-Data.html">http://www.bkg.bund.de/nn_147094/SharedDocs/Download/Barrierefreie-Textversionen/EN-InfoMaterial/EN-Text-Vector-Data.html</a><a href="#fnref116">&#8617;</a>
			</p>
			<div class="row" id="fig:utm">
				<div class="col col-12 col-sm-6 col-md-12"><img src="figs/utm.jpg" class="img-fluid" /><p class="small text-center">(a)</p></div>
				<div class="col col-12 col-sm-6 col-md-12"><img src="figs/utm2.jpg" class="img-fluid" /><p class="small text-center">(b)</p></div>
				<div class="col col-12"><p class="small text-justify">Figure 7.6: Simple 2D+scale datasets from <a href="bibliography.html#Meijers11">Meijers [2011]</a>, which represent the generalisation of a planar partition by merging areas. The dataset shown in (a) has realistic scale intervals such that the generalisation operations are performed at scales that depend on the area of a polygon, while the dataset in (b) uses equally spaced generalisation operations.<a href="#fig:utmref">&#8617;</a></p></div>
			</div>
		</div>
	</div>
	<div class="row">
		<div class="col col-4 col-md-3"><p class="text-left"><a href="extrusion.html"><i class="fa fa-angle-double-left"></i> 6 Extrusion</a></p></div>
		<div class="col col-4 col-md-3"><p class="text-center"><a href="index.html"><i class="fa fa-angle-double-up"></i> Contents <i class="fa fa-angle-double-up"></i></a></p></div>
		<div class="col col-4 col-md-3"><p class="text-right"><a href="linking-lods.html">8 Linking corresponding 3D models <i class="fa fa-angle-double-right"></i></a></p></div>
	</div>
</div>